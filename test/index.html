<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>High-FPS WebGL + Throttled Camera Check</title>
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%; background: black; overflow: hidden;
    }
    #glCanvas {
      display: block;
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
    }
    /* Hidden elements for camera-based brightness detection */
    #video, #camCanvas { display: none; }
  </style>
</head>
<body>

<!-- WebGL Canvas -->
<canvas id="glCanvas"></canvas>

<!-- Hidden camera elements for brightness detection -->
<video id="video" playsinline></video>
<canvas id="camCanvas" width="32" height="32"></canvas>

<script>
(function() {
  // ---------------------------------------------------------
  // 1) Parse URL params
  // ---------------------------------------------------------
  const params = new URLSearchParams(window.location.search);
  const mode      = params.get('mode') || 'test'; 
  const freq      = parseFloat(params.get('frequency') || '120');
  const rps       = parseFloat(params.get('rps') || '3.75');
  const numViews  = parseFloat(params.get('numViews') || '32');
  const skipSprite= 32 / numViews;

  // framesToSwitch => how many frames pass before toggling
  let framesToSwitch;
  if (mode === 'test') {
    framesToSwitch = (freq / rps) * 0.5;
  } else if (mode === 'viking32' || mode === 'statue32') {
    framesToSwitch = (freq / rps) * (1 / numViews);
  } else {
    framesToSwitch = (freq / rps) * 0.25;
  }
  framesToSwitch = Math.round(framesToSwitch);
  if (framesToSwitch < 1) framesToSwitch = 1;

  // ---------------------------------------------------------
  // 2) WebGL Setup
  // ---------------------------------------------------------
  const canvas = document.getElementById('glCanvas');
  const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
  if (!gl) {
    alert('WebGL not supported');
    return;
  }

  function resizeCanvas() {
    const h = window.innerHeight;
    const w = h / 2; // half the height => tall vertical layout

    canvas.style.height = h + 'px';
    canvas.style.width  = w + 'px';

    canvas.width  = w;
    canvas.height = h;
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Toggle fullscreen on canvas click
  canvas.addEventListener('click', () => {
    if (!document.fullscreenElement) {
      canvas.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  });

  // ---------------------------------------------------------
  // 3) Shaders
  // ---------------------------------------------------------
  const vsSource = `
    attribute vec2 aPosition;
    attribute vec2 aTexCoord;
    attribute float aColorMode;

    varying vec2  vTexCoord;
    varying float vColorMode;

    void main(void) {
      vTexCoord  = aTexCoord;
      vColorMode = aColorMode;
      gl_Position = vec4(aPosition, 0.0, 1.0);
    }
  `;

  const fsSource = `
    precision mediump float;

    varying vec2  vTexCoord;
    varying float vColorMode;

    uniform vec4  uSolidColor;
    uniform sampler2D uSampler;

    void main(void) {
      if (vColorMode > 0.5) {
        gl_FragColor = uSolidColor;  // test mode => solid color
      } else {
        gl_FragColor = texture2D(uSampler, vTexCoord);
      }
    }
  `;

  function loadShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error('Shader compile error:', gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  const vertexShader   = loadShader(gl.VERTEX_SHADER, vsSource);
  const fragmentShader = loadShader(gl.FRAGMENT_SHADER, fsSource);

  const shaderProgram = gl.createProgram();
  gl.attachShader(shaderProgram, vertexShader);
  gl.attachShader(shaderProgram, fragmentShader);
  gl.linkProgram(shaderProgram);
  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(shaderProgram));
    return;
  }
  gl.useProgram(shaderProgram);

  // Attribute/uniform locations
  const aPosition   = gl.getAttribLocation(shaderProgram, 'aPosition');
  const aTexCoord   = gl.getAttribLocation(shaderProgram, 'aTexCoord');
  const aColorMode  = gl.getAttribLocation(shaderProgram, 'aColorMode');
  const uSolidColor = gl.getUniformLocation(shaderProgram, 'uSolidColor');
  const uSampler    = gl.getUniformLocation(shaderProgram, 'uSampler');

  // ---------------------------------------------------------
  // 4) Buffers
  // ---------------------------------------------------------
  const buffer = gl.createBuffer();

  function createBufferData(posArray, texArray, colModeArray) {
    const data = [];
    for (let i = 0; i < posArray.length; i += 2) {
      data.push(
        posArray[i],   posArray[i+1],   // position
        texArray[i],   texArray[i+1],   // texCoord
        colModeArray[i/2]              // colorMode
      );
    }
    return new Float32Array(data);
  }

  let positions    = null;
  let texcoords    = null;
  let colorModeArr = null;

  function setupQuad(aspect) {
    // Fit sub-frame in [-1..+1]
    let halfW, halfH;
    if (aspect >= 1.0) {
      halfW = 1.0;
      halfH = 1.0 / aspect;
    } else {
      halfH = 1.0;
      halfW = aspect;
    }

    positions = new Float32Array([
      -halfW, -halfH,
       halfW, -halfH,
      -halfW,  halfH,
       halfW,  halfH
    ]);

    if (mode === 'test') {
      texcoords = new Float32Array([0,0, 1,0, 0,1, 1,1]);
      colorModeArr = [1,1,1,1];
    } else {
      texcoords = new Float32Array([0,0, 1,0, 0,1, 1,1]);
      colorModeArr = [0,0,0,0];
    }

    const data = createBufferData(positions, texcoords, colorModeArr);
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
  }

  // ---------------------------------------------------------
  // 5) Texture Loading
  // ---------------------------------------------------------
  let texture       = null;
  let frameCount    = 0;
  let subImageIdx   = 0;
  const colorCyan   = [0,1,1,1];
  const colorRed    = [1,0,0,1];
  let currentColor  = colorCyan;

  const textureImages = {
    viking4:  'viking.png',
    viking32: 'viking32.png',
    statue32: 'statue32.png'
  };

  if (mode in textureImages) {
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

    texture = gl.createTexture();
    const image = new Image();
    image.src = textureImages[mode];
    image.onload = function() {
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,
                    gl.UNSIGNED_BYTE, image);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      let columns = 1, rows = 1;
      if (mode === 'viking4') {
        columns = 4; rows = 1;
      } else if (mode === 'viking32' || mode === 'statue32') {
        columns = 8; rows = 4;
      }

      // For a perfect sub-frame aspect:
      const subAspect = (image.width / columns) / (image.height / rows);
      setupQuad(1.0); 
      requestAnimationFrame(() => render(columns, rows));
    };
  } else {
    // test mode
    setupQuad(1.0);
    requestAnimationFrame(() => render(1,1));
  }

  // ---------------------------------------------------------
  // 6) Main Render Loop at up to 120Hz
  // ---------------------------------------------------------
  function render(columns, rows) {
    gl.clearColor(0,0,0,1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    if (mode === 'test') {
      // Toggle color
      if (frameCount % framesToSwitch === 0) {
        currentColor = (currentColor === colorCyan) ? colorRed : colorCyan;
      }
      gl.uniform4fv(uSolidColor, currentColor);
    } else {
      // multi-frame textures
      const totalFrames = columns * rows;

      if (frameCount % framesToSwitch === 0) {
        if (mode === 'viking32' || mode === 'statue32') {
          // reverse step
          subImageIdx = (subImageIdx - skipSprite + totalFrames) % totalFrames;
        } else {
          // forward step
          subImageIdx = (subImageIdx + skipSprite) % totalFrames;
        }
      }

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.uniform1i(uSampler, 0);

      // figure out col, row
      const col = subImageIdx % columns;
      const row = Math.floor(subImageIdx / columns);
      const invertedRow = (rows - 1) - row;

      const uLeft   = col * (1/columns);
      const uRight  = uLeft + (1/columns);
      const vTop    = invertedRow * (1/rows);
      const vBottom = vTop + (1/rows);

      // update buffer data
      const data = [];
      for (let i = 0; i < 4; i++) {
        const px = positions[i*2], py = positions[i*2 + 1];
        const oldU = (i % 2 === 1) ? 1 : 0;
        const oldV = (i >= 2)      ? 1 : 0;
        const newU = (oldU > 0.5) ? uRight : uLeft;
        const newV = (oldV > 0.5) ? vBottom: vTop;
        data.push(px, py, newU, newV, 0);
      }
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
    }

    // Use program
    gl.useProgram(shaderProgram);

    // Setup attribute pointers
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    const stride = 5 * 4; 
    gl.enableVertexAttribArray(aPosition);
    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, stride, 0);

    gl.enableVertexAttribArray(aTexCoord);
    gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, stride, 2*4);

    gl.enableVertexAttribArray(aColorMode);
    gl.vertexAttribPointer(aColorMode, 1, gl.FLOAT, false, stride, 4*4);

    // Draw
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    frameCount++;
    requestAnimationFrame(() => render(columns, rows));  // up to device’s max refresh
  }

  /* =====================================================
   * CAMERA BRIGHTNESS DETECTION (Throttled)
   * ===================================================== */
  async function startCamera() {
    try {
      const constraints = {
        audio: false,
        video: {
          facingMode: 'environment',
          frameRate: { ideal: 60, max: 60 }, // not guaranteed
          width: { ideal: 640 },
          height:{ ideal: 480 }
        }
      };
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      const videoEl = document.getElementById('video');
      videoEl.srcObject = stream;
      await videoEl.play();

      // Instead of doing camera checks every animation frame,
      // we do them ~60 times/second to reduce overhead.
      // If we want to push it more, we can reduce the interval.
      const intervalMs = 16; // ~60 checks/s
      setInterval(checkBrightness, intervalMs);
    } catch (err) {
      console.error('Camera error:', err);
    }
  }

  function checkBrightness() {
    const videoEl = document.getElementById('video');
    const camCanvas = document.getElementById('camCanvas');
    const ctx = camCanvas.getContext('2d');

    // Draw video frame to small 32x32 canvas
    ctx.drawImage(videoEl, 0, 0, camCanvas.width, camCanvas.height);

    // Get pixel data
    const frameData = ctx.getImageData(0, 0, camCanvas.width, camCanvas.height);
    const data = frameData.data;

    // Skip most pixels to reduce overhead further
    // e.g. read every 16th pixel => 1/4 of them if you want even faster
    let sum = 0;
    let count = 0;
    for (let i = 0; i < data.length; i += 16) {
      // data[i], data[i+1], data[i+2] => R, G, B
      const avg = (data[i] + data[i+1] + data[i+2]) / 3;
      sum += avg;
      count++;
    }
    const brightness = sum / count;

    // If brightness is above some threshold => reset
    const threshold = 200;  // Adjust as needed
    if (brightness > threshold) {
      subImageIdx = 0;
    }
  }

  // Start camera once the page loads
  window.addEventListener('load', startCamera);
})();
</script>

</body>
</html>
