<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Canvas Half-Width, Full-Height + No-Cropping</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: black;
      overflow: hidden;
    }
    /* The canvas is absolutely positioned; we'll center it horizontally. */
    #glCanvas {
      display: block;
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
    }
  </style>
</head>
<body>
<canvas id="glCanvas"></canvas>

<script>
(function() {
  // ---------------------------------------------------------
  // 1) Parse URL params: mode, frequency, rps
  // ---------------------------------------------------------
  const params = new URLSearchParams(window.location.search);
  const mode = params.get('mode') || 'test'; // "test" or "texture"
  const freq = parseFloat(params.get('frequency') || '4');
  const rps  = parseFloat(params.get('rps') || '2');

  // framesToSwitch => how many frames pass before toggling color or moving sub-frame
  let framesToSwitch = (mode === 'test') 
    ? (freq / rps) * 0.5
    : (freq / rps) * 0.25;
  framesToSwitch = Math.round(framesToSwitch);
  if (framesToSwitch < 1) framesToSwitch = 1;

  // ---------------------------------------------------------
  // 2) Canvas and WebGL setup
  // ---------------------------------------------------------
  const canvas = document.getElementById('glCanvas');
  const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
  if (!gl) {
    alert('WebGL not supported');
    return;
  }

  // Resize: full window height, half that width (in normal mode)
  function resizeCanvas() {
    const h = window.innerHeight;
    const w = h / 2; // half the height

    // CSS size
    canvas.style.height = h + 'px';
    canvas.style.width  = w + 'px';

    // Actual drawing buffer size
    canvas.width  = w;
    canvas.height = h;

    // Update viewport
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Toggle fullscreen on a single click
  canvas.addEventListener('click', () => {
    if (!document.fullscreenElement) {
      canvas.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  });

  // ---------------------------------------------------------
  // 3) Shaders
  // ---------------------------------------------------------
  const vsSource = `
    attribute vec2 aPosition;
    attribute vec2 aTexCoord;
    attribute float aColorMode;

    varying vec2  vTexCoord;
    varying float vColorMode;

    void main(void) {
      vTexCoord  = aTexCoord;
      vColorMode = aColorMode;
      gl_Position = vec4(aPosition, 0.0, 1.0);
    }
  `;

  const fsSource = `
    precision mediump float;

    varying vec2  vTexCoord;
    varying float vColorMode;

    uniform vec4  uSolidColor;
    uniform sampler2D uSampler;

    void main(void) {
      // If vColorMode > 0.5 => "test" mode => solid color
      // else => "texture" mode => sample from sprite
      if (vColorMode > 0.5) {
        gl_FragColor = uSolidColor;
      } else {
        gl_FragColor = texture2D(uSampler, vTexCoord);
      }
    }
  `;

  function loadShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error('Error compiling shader:', gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  const vertexShader   = loadShader(gl.VERTEX_SHADER, vsSource);
  const fragmentShader = loadShader(gl.FRAGMENT_SHADER, fsSource);

  const shaderProgram = gl.createProgram();
  gl.attachShader(shaderProgram, vertexShader);
  gl.attachShader(shaderProgram, fragmentShader);
  gl.linkProgram(shaderProgram);

  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
    console.error('Could not link shader program:', gl.getProgramInfoLog(shaderProgram));
    return;
  }

  gl.useProgram(shaderProgram);

  // Location lookups
  const aPosition   = gl.getAttribLocation(shaderProgram, 'aPosition');
  const aTexCoord   = gl.getAttribLocation(shaderProgram, 'aTexCoord');
  const aColorMode  = gl.getAttribLocation(shaderProgram, 'aColorMode');
  const uSolidColor = gl.getUniformLocation(shaderProgram, 'uSolidColor');
  const uSampler    = gl.getUniformLocation(shaderProgram, 'uSampler');

  // ---------------------------------------------------------
  // 4) Buffers (interleaved): [pos.x, pos.y, tex.x, tex.y, colorMode]
  // ---------------------------------------------------------
  const buffer = gl.createBuffer();

  function createBufferData(posArray, texArray, colModeArray) {
    // Each vertex => 5 floats
    //  pos(2), tex(2), colorMode(1)
    const data = [];
    for (let i = 0; i < posArray.length; i += 2) {
      data.push(
        posArray[i],     posArray[i + 1],     // position
        texArray[i],     texArray[i + 1],     // texCoord
        colModeArray[i/2]                   // colorMode
      );
    }
    return new Float32Array(data);
  }

  let positions    = null;
  let texcoords    = null;
  let colorModeArr = null;

  function setupQuad(fullAspect) {
    // "fullAspect" is the aspect ratio of the sub-image: width/height
    // We want to ensure we see the entire sub-image in [-1..+1].
    // If fullAspect >= 1 => wider => fit width to -1..+1 => total width=2 => height=2/fullAspect
    // If fullAspect < 1 => taller => fit height to -1..+1 => total height=2 => width=2*fullAspect

    let halfWidth, halfHeight;
    if (fullAspect >= 1.0) {
      // wide => X from -1..+1, Y from -1/aspect..+1/aspect
      halfWidth  = 1.0;
      halfHeight = 1.0 / fullAspect;
    } else {
      // tall => Y from -1..+1, X from -aspect..+aspect
      halfHeight = 1.0;
      halfWidth  = fullAspect;
    }

    positions = new Float32Array([
      -halfWidth, -halfHeight,
       halfWidth, -halfHeight,
      -halfWidth,  halfHeight,
       halfWidth,  halfHeight
    ]);

    if (mode === 'test') {
      // Just fill the entire texture space [0..1,0..1]
      texcoords = new Float32Array([
        0, 0,
        1, 0,
        0, 1,
        1, 1
      ]);
      colorModeArr = [1,1,1,1]; // 1 => "test" in FS
    } else {
      // mode="texture"
      // Start w/ the entire [0..1, 0..1]. We'll adjust sub-frame each frame
      texcoords = new Float32Array([
        0, 0,
        1, 0,
        0, 1,
        1, 1
      ]);
      colorModeArr = [0,0,0,0]; // 0 => "texture"
    }

    const data = createBufferData(positions, texcoords, colorModeArr);
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
  }

  // ---------------------------------------------------------
  // 5) Texture loading (if mode=texture)
  // ---------------------------------------------------------
  let texture       = null;
  let frameCount    = 0;
  let subImageIdx   = 0;
  const colorCyan   = [0, 1, 1, 1];
  const colorRed    = [1, 0, 0, 1];
  let currentColor  = colorCyan;

  if (mode === 'texture') {
    // Flip Y so image isnâ€™t upside-down
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

    texture = gl.createTexture();
    const image = new Image();
    image.src = 'viking.png'; // must be in the same folder
    image.onload = function() {
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      // fullAspect => image.width / image.height
      // BUT remember: we see only a sub-frame that is 1/4 of the total width
      // so the sub-frame aspect is (image.width/4) / image.height = (image.width / image.height) * (1/4)
      // If we want to see the sub-frame fully (no cropping), multiply aspect by 0.25.
      const fullAspect = (image.width / 4) / image.height;

      setupQuad(1.0);
      requestAnimationFrame(render);
    };
  } else {
    // mode="test"
    setupQuad(1.0); // aspect=1 => square (just fill [-1..+1] both axes)
    requestAnimationFrame(render);
  }

  // ---------------------------------------------------------
  // 6) Render loop
  // ---------------------------------------------------------
  function render() {
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    if (mode === 'test') {
      // Toggle color every framesToSwitch
      if (frameCount % framesToSwitch === 0) {
        currentColor = (currentColor === colorCyan) ? colorRed : colorCyan;
      }
      gl.uniform4fv(uSolidColor, currentColor);

    } else {
      // mode="texture"
      // Switch sub-frame every framesToSwitch
      if (frameCount % framesToSwitch === 0) {
        subImageIdx = (subImageIdx + 1) % 4; // 0..3
      }
      // Bind texture & set uniform
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.uniform1i(uSampler, 0);

      // We want to show the sub-frame [ (0.25 * subImageIdx) .. (0.25 * subImageIdx + 0.25) ] in X
      // The original texcoords are [ (0,0), (1,0), (0,1), (1,1) ].
      // We'll rebuild them each frame with a shift in X.
      const baseLeft  = 0.25 * subImageIdx;
      const baseRight = baseLeft + 0.25;

      const data = [];
      for (let i = 0; i < 4; i++) {
        const px = positions[i * 2];
        const py = positions[i * 2 + 1];

        // original uv => i=0 => (0,0), i=1 => (1,0), i=2 => (0,1), i=3 => (1,1)
        const oldU = (i % 2 === 1) ? 1.0 : 0.0;
        const oldV = (i >= 2)      ? 1.0 : 0.0;

        const newU = oldU * 0.25 + baseLeft;
        const newV = oldV;
        const cm   = colorModeArr[i];

        data.push(px, py, newU, newV, cm);
      }
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
    }

    // Use program
    gl.useProgram(shaderProgram);

    // Set up attribute pointers
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    const stride = 5 * 4; // 5 floats per vertex => 20 bytes
    gl.enableVertexAttribArray(aPosition);
    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, stride, 0);

    gl.enableVertexAttribArray(aTexCoord);
    gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, stride, 2 * 4);

    gl.enableVertexAttribArray(aColorMode);
    gl.vertexAttribPointer(aColorMode, 1, gl.FLOAT, false, stride, 4 * 4);

    // Draw
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    frameCount++;
    requestAnimationFrame(render);
  }
})();
</script>

</body>
</html>